# Level13

Once again we have a setuid executable, which can be found in `vulnerable.c`. Unfortunately the 'juicy' part has been removed. The vulnerable part lies in the `getuid()` syscall, which checks if the user's ID is equal to 1000; if it isn't then the program immediately exits.

```c
#define FAKEUID 1000

// ...

if(getuid() != FAKEUID) {
    printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), FAKEUID);
    printf("The system administrators will be notified of this violation\n");
    exit(EXIT_FAILURE);
}

// ...

printf("your token is %s\n", token);
```

If the user ID is correct, the `token` array is filled with some values and then printed, which turns out to be the password to the `flag13` account.

> At first, I did not realise that `token` was the password. I recovered the token almost immediately, and was unsatisfied. Then I went down a huge rabbit hole by attempting to inject my **own** shared library and overwrite the `getuid` syscall. This proved fruitless, since it turns out that setuid programs have measures in place to prevent this! The real solution is much easier.

We can run the program with `gdb` to manipulate the memory, _overwrite_ the user ID, and cause the `getuid() != FAKEUID)` check to be false. 

First, we can print the assembly of the `main` function with `disassemble main`:

```
level13@nebula:/home/flag13$ gdb flag13 
(gdb) disassemble main
Dump of assembler code for function main:
    0x080484c4 <+0>:     push   %ebp
    0x080484c5 <+1>:     mov    %esp,%ebp
    0x080484c7 <+3>:     push   %edi
    0x080484c8 <+4>:     push   %ebx
    0x080484c9 <+5>:     and    $0xfffffff0,%esp
    0x080484cc <+8>:     sub    $0x130,%esp
    0x080484d2 <+14>:    mov    0xc(%ebp),%eax
    0x080484d5 <+17>:    mov    %eax,0x1c(%esp)
    0x080484d9 <+21>:    mov    0x10(%ebp),%eax
    0x080484dc <+24>:    mov    %eax,0x18(%esp)
    0x080484e0 <+28>:    mov    %gs:0x14,%eax
    0x080484e6 <+34>:    mov    %eax,0x12c(%esp)
    0x080484ed <+41>:    xor    %eax,%eax
    0x080484ef <+43>:    call   0x80483c0 <getuid@plt> // The first call to getuid()
    0x080484f4 <+48>:    cmp    $0x3e8,%eax            // getuid() == FAKEUID, let's break HERE!!
    0x080484f9 <+53>:    je     0x8048531 <main+109>
    0x080484fb <+55>:    call   0x80483c0 <getuid@plt>
    0x08048500 <+60>:    mov    $0x80486d0,%edx

    // I've trimmed the output here because the rest of main is very long!
```

There's quite a lot going on, so I've trimmed most of the output down. We're interested in 'spoofing' the return value of `getuid`, so let's set a breakpoint immediately _after_ the call to `getuid`, which will be at line `0x080484f4 <+48>:    cmp    $0x3e8,%eax`. Note that it's comparing the value in `0x3e8` (this will be `FAKEUID`) to the value in register `eax` (this will be the return value of `getuid()`).

```
(gdb) break *0x080484f4
Breakpoint 1 at 0x80484f4
(gdb) run
Starting program: /home/flag13/flag13 

Breakpoint 1, 0x080484f4 in main ()
(gdb) p $eax
$1 = 1014
```

Sure enough, if we check the user ID stored in `eax`, it's the user ID of `level13` as we'd expect. Now, it's as simple as overwriting the `eax` with `set $eax=1000` and continuing the execution.

```
(gdb) set $eax=1000
(gdb) c
Continuing.
your token is <TOKEN REDACTED>
[Inferior 1 (process 2711) exited with code 063]
(gdb) q
level13@nebula:/home/flag13$ su flag13
Password: 
sh-4.2$ getflag
You have successfully executed getflag on a target account
```

:) 